## Part 1. Настройка gitlab-runner  
#### Поднимаем виртуальную машину  
![img1](img/img1.png)

#### Скачиваем и устанавливаем gitlab-runner  

#### Установить и обновить пакеты на машине:

- sudo apt install make
- sudo apt install gcc
- sudo apt-get update
- sudo apt-get upgrade
![img2](img/img2_install.png)

`curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh"|sudo bash`

![img3](img/img3_gitlab_runner.png)

#### Запустить gitlab-runner и зарегистрировать его для использования в текущем проекте (DO6_CICD). Для регистрации понадобятся URL и токен, которые можно получить на страничке задания на платформе. 

- sudo gitlab-runner start
- sudo gitlab-runner register

![img4](img/img4_start.png)
## Part 2. Сборка

**== Задание ==**

#### Написать этап для **CI** по сборке приложений из проекта *C2_SimpleBashUtils*
#### В файле _gitlab-ci.yml_ добавить этап запуска сборки через мейк файл из проекта C2
#### Файлы, полученные после сборки (артефакты), сохранять в произвольную директорию со сроком хранения 30 дней.
- Скопировал папки cat и grep из проекта simpleBashUtils в папку src проекта CICD: 

![img5](img/img_5_folder.png)

- создал и описал файл .gitlab-ci.yml
    - Файл .gitlab-ci.yml - это файл конфигурации для настройки и определения задач и пайплайнов непрерывной интеграции и непрерывной доставки (CI/CD) в GitLab. В этом файле вы описываете, какие шаги должны выполняться автоматически при каждом пуше кода в ваш репозиторий. После добавления .gitlab-ci.yml файла в ваш репозиторий, GitLab CI/CD будет автоматически создавать пайплайны и выполнять задачи согласно вашим настройкам. Вы сможете видеть результаты выполнения задач в веб-интерфейсе GitLab, а также настраивать уведомления, автоматическое развертывание и другие аспекты CI/CD процесса.

![img6](img/img_6_gitlab_yml.png)
![img7](img/img_7_jobs.png)

### Part 3. Тест кодстайла

**== Задание ==**

#### Написать этап для **CI**, который запускает скрипт кодстайла (*clang-format*):
#### Если кодстайл не прошел, то "зафейлить" пайплайн

- После выполения команды clang-format исходный код изменяется и строка __git diff --exit-code__ как раз и показывает различия между закомиченым вараинтом и измененым. Если различия есть строка возвращает 1.

![img8](img/img_8_clan_format.png)

#### В пайплайне отобразить вывод утилиты *clang-format*

![img9](img/img9.png)
![img10](img/img10.png)

## Part 4. Интеграционные тесты

**== Задание ==**
#### Написать этап для **CI**, который запускает ваши интеграционные тесты из того же проекта:
#### Запускать этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно
#### Если тесты не прошли, то "зафейлить" пайплайн

- Мои тесты возвращают 2 строки:  количество SUCCESS и FAIL тестов. Таким образом для фела пеплайна необходимо чтобы в строке FAIL было значение не 0, то есть хотябы 1 тест был зафейлен. Для этого в скрипте запускаем тесты и смотрим на строку FAIL, если она не равна 0, то роняем пеплайн.

![img11](img/img11_test.png)

#### В пайплайне отобразить вывод, что интеграционные тесты провалились, потому что я поставил тест, который точно будет FAIL

![img12](img/img121.png)
![img13](img/img122.png)

#### В пайплайне отобразить вывод, что интеграционные тесты прошли, потому что FAIL: 0

![img14](img/img13.png)

## Part 5. Этап деплоя

**== Задание ==**
#### Подними вторую виртуальную машину Ubuntu Server 22.04 LTS*

![img15](img/img15_clone.png)

#### Написать этап для **CD**, который "разворачивает" проект на другой виртуальной машине:
#### Запускать этот этап вручную при условии, что все предыдущие этапы прошли успешно

- Изменяем файл /etc/netplan/00-installer-config.yaml на обеих машинах:

![ing16](img/img16.png)
![img17](img/img17.png)

- Пропингуем первую машину со втрой, чтобы убедиться, что соединение есть:

![img](img/img18.png)

#### Заходим на первой машине под пользователя gitlab-runner(sudo su gitlab-runner), создаём ключ (ssh-keygen) и копируем его на вторую машину(ssh-copy-id user@ip (laciea@10.10.0.2)  )

![img19](img/img19.png)

#### Теперь мы можем подключаться ко второй машине через ssh без необходимости ввода пароля:

![img20](img/img20.png)

- На второй машине дадим права для папки /usr/local/bin/ командой __sudo chmod -R 777 /usr/local/bin__

![img21](img/img21.png)

#### В файле _gitlab-ci.yml_ добавить этап запуска написанного скрипта

![img](img/img23.png)

#### В случае ошибки "зафейлить" пайплайн

![img](img/img24.png)

В результате вы должны получить готовые к работе приложения из проекта *C2_SimpleBashUtils* (s21_cat и s21_grep) на второй виртуальной машине.

![img](img/img23.png)

#### Сохрани дампы образов виртуальных машин.

![img](img/img25.png)

### Part 6. Дополнительно. Уведомления

**== Задание ==**

#### Настроить уведомления о успешном/неуспешном выполнении пайплайна через бота с именем "[ваш nickname] DO6 CI/CD" в *Telegram*
- первым делом необходимо получить токен бота. Для этого используем инфраструктуру телеграма, а точнее главного бота "BotFather". Выполняем команды и получаем токен.

![omg](img/img26.png)

- далее необходимо получить __id чата__. Для этого в адресной строке браузера забиваем `https://api.telegram.org/bot<тут_твой_токен>/getUpdates`, 
- уже находясь на указанной странице отправьте любое сообщение в чат бота. На странице отобразятся данные, включая id чата в который вы отправили сообщение (поле chat->id):

![img](img/img27.png)

- далее пишем скрипт который будет контролировать работу каждого этама CI/CD:
- part6.sh
- добавляем выполнение скрипта после каждого этапа, итоговый файл .gitlab-ci.yml выглядит так:

![img](img/img28.png)

- коммитим, пушим и проверяем работу бота

![img](img/img29.png)

